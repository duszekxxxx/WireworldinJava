/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Wireworld.windows;

import Wireworld.Logic.LogicOperator;
import Wireworld.Logic.BoardGame;
import Wireworld.Logic.Conductor;
import Wireworld.Logic.ElectronHead;
import Wireworld.Logic.EmptyCell;
import Wireworld.Logic.States;
import Wireworld.generator.WireWorldManager;
import Wireworld.toolsAndSettings.SettingsContainer;
import Wireworld.toolsAndSettings.SettingsManager;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;

/**
 * Klasa odpowiadająca za panel wyświetlający WireWorld(wyświetlanie
 * wizaulizacji)
 */
public class JPanelRealTimeVisualization extends javax.swing.JPanel {

    private int columns;
    private int rows;
    private int generation;
    private LogicOperator logic;
    private int currentCellSize;
    private int primaryCellSize;
    private int primaryDistanceBetweenCells;
    private int currentDistanceBetweenCells;
    private int zoom;
    private int currentBoardWidth;
    private int primaryBoardWidth;
    private Color boarderColor;

    /**
     * Konstruktor JPanelRealTimeVisualization
     */
    public JPanelRealTimeVisualization() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Metoda służy do załadowania podstawowych informacji potrzebnych do
     * rysowania takich jak: plansza i ustawienia
     *
     */
    public void setUpJPanel() {
        BoardGame board = WireWorldManager.getInstance().getBoard();
        SettingsContainer settingsContainer = SettingsManager.getInstance().getSettingsContainer();
        logic = new LogicOperator();
        logic.generate(board, settingsContainer.getGenerationCount());
        columns = board.getHorizontalSize();
        rows = board.getVerticalSize();
        primaryCellSize = settingsContainer.getCellSize();
        primaryDistanceBetweenCells = settingsContainer.getDistanceBetweenCells();
        primaryBoardWidth = settingsContainer.getFrameWidth();
        boarderColor = settingsContainer.getBoarderColor();
        //Set first value, before any zoom changing
        currentCellSize = primaryCellSize;
        currentDistanceBetweenCells = primaryDistanceBetweenCells;
        currentBoardWidth = primaryBoardWidth;
        zoom = 100;
        Dimension panelSize = new Dimension(getPanelHeight(), getPanelWidth());
        setPreferredSize(panelSize);
    }

    /**
     * Metoda pozwala na ustawienie numeru generacji, która ma być wyświetlana
     *
     * @param generation numer generacji
     */
    public void refreshJPanel(int generation) {
        this.generation = generation;
    }

    /**
     * Metoda pozwala na odpowiednie wyskalowanie(zoomowanie) planszy
     *
     * @param zoom rozmiar powiększenia/pomniejszenia w procentach
     */
    public void zoom(int zoom) {
        currentCellSize = primaryCellSize * zoom / 100;
        if (primaryCellSize > 0 && currentCellSize == 0) {
            currentCellSize = 1;
        }
        currentDistanceBetweenCells = primaryDistanceBetweenCells * zoom / 100;
        if (primaryDistanceBetweenCells > 0 && currentDistanceBetweenCells == 0) {
            currentDistanceBetweenCells = 1;
        }
        currentBoardWidth = primaryBoardWidth * zoom / 100;
        Dimension newSize = new Dimension(getPanelHeight(), getPanelWidth());
        setPreferredSize(newSize);
        this.zoom = zoom;
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        if (zoom > 0) {
            BoardGame board = logic.getGeneration(generation);
            Graphics2D g2d = (Graphics2D) g;
            int currentWidth = currentBoardWidth;
            int currentHeight = currentBoardWidth;
            g2d.setColor(boarderColor);
            g2d.fillRect(0, 0, getPanelHeight(), getPanelWidth());
            for (int i = 0; i < columns; i++) {
                for (int j = 0; j < rows; j++) {
                    States value = board.getPointOnBoard(i, j);
                    g2d.setColor(checkCellColor(value));
                    g2d.fillRect(currentHeight, currentWidth, currentCellSize, currentCellSize);
                    currentWidth += currentCellSize + currentDistanceBetweenCells;
                }
                currentHeight += currentCellSize + currentDistanceBetweenCells;
                currentWidth = currentBoardWidth;
            }
        }
    }

    private Color checkCellColor(States value) {
        if (value instanceof EmptyCell) {
            return Color.BLACK;
        } else if (value instanceof Conductor) {
            return Color.YELLOW;
        } else if (value instanceof ElectronHead) {
            return Color.BLUE;
        } else {
            return Color.RED;
        }
    }

    private int getPanelHeight() {
        int result = currentBoardWidth * 2;
        result += columns * currentCellSize;
        result += (columns - 1) * +currentDistanceBetweenCells;
        return result;
    }

    private int getPanelWidth() {
        int result = currentBoardWidth * 2;
        result += rows * currentCellSize;
        result += (rows - 1) * +currentDistanceBetweenCells;
        return result;
    }

    /**
     * Metoda pozwala na otrzymanie generacji o konkretnym numerze
     *
     * @param i numer generacji
     * @return zwraca wybraną generację
     */
    public BoardGame getGeneration(int i) {
        return logic.getGeneration(i);
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
